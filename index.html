<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Audio Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  :root { --c1: #ff006e; --c2: #8338ec; --c3: #3a86ff; }
  body {
    background: #000; display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    min-height: 100dvh; overflow: hidden;
    font-family: 'Space Mono', monospace; color: #fff;
    touch-action: manipulation;
  }
  canvas { position: fixed; inset: 0; width: 100%; height: 100%; z-index: 0; }
  .ui {
    position: fixed; z-index: 10; display: flex; flex-direction: column;
    align-items: center; gap: 18px; transition: opacity 0.5s; padding: 20px;
  }
  .ui.hidden { opacity: 0; pointer-events: none; }
  .title {
    font-family: 'Bebas Neue', sans-serif; font-size: clamp(2.8rem, 12vw, 5rem);
    letter-spacing: 0.2em;
    background: linear-gradient(135deg, var(--c1) 0%, var(--c2) 50%, var(--c3) 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
  }
  .mode-row { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
  .mode-btn {
    padding: 7px 16px; border: 1px solid rgba(255,255,255,0.2); border-radius: 20px;
    background: transparent; color: rgba(255,255,255,0.45);
    font-family: 'Space Mono', monospace; font-size: 0.62rem;
    letter-spacing: 0.06em; cursor: pointer; transition: all 0.2s;
  }
  .mode-btn.active {
    border-color: var(--c1); color: #fff;
    background: rgba(255,0,110,0.18); box-shadow: 0 0 12px rgba(255,0,110,0.35);
  }
  .btn-group { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
  .btn {
    padding: 14px 26px; border: 2px solid transparent; border-radius: 4px;
    background: transparent; color: #fff; font-family: 'Space Mono', monospace;
    font-size: 0.72rem; font-weight: 700; letter-spacing: 0.08em;
    text-transform: uppercase; cursor: pointer; position: relative; overflow: hidden;
  }
  .btn::before {
    content: ''; position: absolute; inset: 0;
    background: linear-gradient(135deg, var(--c1), var(--c2)); opacity: 0.12;
  }
  .btn:active { transform: scale(0.97); }
  .btn-primary   { border-color: var(--c1); box-shadow: 0 0 18px rgba(255,0,110,0.35); }
  .btn-secondary { border-color: var(--c2); box-shadow: 0 0 18px rgba(131,56,236,0.35); }
  .palette-row { display: flex; gap: 12px; align-items: center; }
  .pal {
    width: 30px; height: 30px; border-radius: 50%;
    border: 2px solid transparent; cursor: pointer; transition: transform 0.2s, border-color 0.2s;
  }
  .pal:hover, .pal.active { transform: scale(1.25); border-color: #fff; }
  .pal-neon    { background: linear-gradient(135deg, #ff006e, #8338ec); }
  .pal-fire    { background: linear-gradient(135deg, #ff4d00, #ffbe0b); }
  .pal-ocean   { background: linear-gradient(135deg, #00b4d8, #06d6a0); }
  .pal-mono    { background: linear-gradient(135deg, #fff, #555); }
  .pal-love    { background: linear-gradient(135deg, #ff1a75, #ffb3d1); }
  .pal-drive   { background: linear-gradient(135deg, #6600ff, #ffffff); }
  .pal-liminal { background: linear-gradient(135deg, #d4f0a0, #f7c59f); }
  .hint {
    font-size: 0.62rem; color: rgba(255,255,255,0.35);
    letter-spacing: 0.04em; text-align: center; max-width: 300px; line-height: 1.7;
  }
  .controls {
    position: fixed; bottom: 36px; left: 50%; transform: translateX(-50%);
    z-index: 10; display: flex; gap: 14px; align-items: center;
    opacity: 0; pointer-events: none; transition: opacity 0.4s;
  }
  .controls.visible { opacity: 1; pointer-events: all; }
  .ctrl-btn {
    width: 54px; height: 54px; border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.18); background: rgba(0,0,0,0.55);
    color: #fff; font-size: 1.1rem; cursor: pointer;
    display: flex; align-items: center; justify-content: center;
  }
  .ctrl-btn:active { transform: scale(0.93); }
  .track-name {
    position: fixed; top: 28px; left: 50%; transform: translateX(-50%); z-index: 10;
    font-family: 'Bebas Neue', sans-serif; font-size: 1.1rem; letter-spacing: 0.22em;
    color: rgba(255,255,255,0.6); opacity: 0; transition: opacity 0.5s;
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    max-width: 80vw; text-align: center;
  }
  .track-name.visible { opacity: 1; }
  #fileInput { display: none; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div class="ui" id="ui">
  <div class="title">VISUALIZER</div>
  <div class="mode-row">
    <button class="mode-btn active" data-mode="radial" onclick="setMode(this)">RADIAL</button>
    <button class="mode-btn" data-mode="bars"   onclick="setMode(this)">BARS</button>
    <button class="mode-btn" data-mode="wave"   onclick="setMode(this)">WAVE</button>
    <button class="mode-btn" data-mode="galaxy" onclick="setMode(this)">GALAXY</button>
    <button class="mode-btn" data-mode="bubble" onclick="setMode(this)">ORB</button>
  </div>
  <div class="btn-group">
    <button class="btn btn-primary"   onclick="document.getElementById('fileInput').click()">‚¨Ü Importer un son</button>
    <button class="btn btn-secondary" onclick="startMic()">üé§ Micro live</button>
  </div>
  <div class="palette-row">
    <div class="pal pal-neon    active" onclick="setPalette('neon',this)"    title="Neon"></div>
    <div class="pal pal-fire"           onclick="setPalette('fire',this)"    title="Fire"></div>
    <div class="pal pal-ocean"          onclick="setPalette('ocean',this)"   title="Ocean"></div>
    <div class="pal pal-mono"           onclick="setPalette('mono',this)"    title="Mono"></div>
    <div class="pal pal-love"           onclick="setPalette('love',this)"    title="Love"></div>
    <div class="pal pal-drive"          onclick="setPalette('drive',this)"   title="Drive"></div>
    <div class="pal pal-liminal"        onclick="setPalette('liminal',this)" title="Liminal"></div>
  </div>
  <div class="hint">Importe un fichier audio/vid√©o ou active le micro.<br>Enregistre l'√©cran et poste sur TikTok üéµ</div>
</div>

<div class="track-name" id="trackName"></div>

<div class="controls" id="controls">
  <button class="ctrl-btn" id="playPauseBtn" onclick="togglePlay()">‚è∏</button>
  <button class="ctrl-btn" onclick="toggleAllUI()">üëÅ</button>
  <button class="ctrl-btn" onclick="showUI()">‚ú¶</button>
</div>

<input type="file" id="fileInput" accept="audio/*,video/mp4,video/quicktime,video/mov" onchange="loadFile(event)">

<script>
/* =====================================================
   AUDIO ENGINE
===================================================== */
let actx, analyser, freqData, waveData;
let bufSrc      = null;    // BufferSource ‚Äî for decoded audio files
let mediaEl     = null;    // HTMLVideoElement ‚Äî for video files (iOS-safe)
let audioBuffer = null;
let micStream   = null;
let isPlaying = false, isMic = false, isMediaEl = false;
let pausedAt  = 0, startedAt = 0;

function ensureCtx() {
  if (!actx) {
    actx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = actx.createAnalyser();
    analyser.fftSize               = 512;
    analyser.smoothingTimeConstant = 0.5;
    analyser.minDecibels           = -90;
    analyser.maxDecibels           = -10;
    freqData = new Uint8Array(analyser.frequencyBinCount);
    waveData = new Uint8Array(analyser.fftSize);
  }
  actx.resume();
}

async function loadFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  stopAll();
  ensureCtx();
  isMic = false;

  const isVideo = file.type.startsWith('video/');

  if (isVideo) {
    /*
      VIDEO PATH ‚Äî use createMediaElementSource so Safari decodes
      the video natively (handles HEVC .mov, H.264 .mp4, AAC audio).
      decodeAudioData would fail or return silence on many iOS video formats.
    */
    isMediaEl = true;
    audioBuffer = null;

    mediaEl = document.createElement('video');
    mediaEl.src = URL.createObjectURL(file);
    mediaEl.crossOrigin = 'anonymous';
    mediaEl.playsInline = true;
    mediaEl.style.display = 'none';
    document.body.appendChild(mediaEl);

    const mediaSrc = actx.createMediaElementSource(mediaEl);
    mediaSrc.connect(analyser);
    analyser.connect(actx.destination);

    mediaEl.onended = () => {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '‚ñ∂';
    };

    await mediaEl.play();
    isPlaying = true;
    document.getElementById('playPauseBtn').textContent = '‚è∏';

  } else {
    /*
      AUDIO PATH ‚Äî decodeAudioData is optimal for audio-only files
      and gives us accurate seek/pause via BufferSource offset.
    */
    isMediaEl = false;
    const ab = await file.arrayBuffer();
    audioBuffer = await actx.decodeAudioData(ab);
    pausedAt = 0;
    doPlay(0);
  }

  setTrackName(file.name.replace(/\.[^.]+$/, '').toUpperCase());
  hideUI();
  showControls();
}

function doPlay(offset) {
  if (!audioBuffer) return;
  if (bufSrc) { try { bufSrc.disconnect(); bufSrc.stop(); } catch(e){} }
  bufSrc = actx.createBufferSource();
  bufSrc.buffer = audioBuffer;
  bufSrc.connect(analyser);
  analyser.connect(actx.destination);
  bufSrc.start(0, offset);
  bufSrc.onended = () => {
    if (isPlaying) {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '‚ñ∂';
    }
  };
  startedAt = actx.currentTime - offset;
  isPlaying = true;
  document.getElementById('playPauseBtn').textContent = '‚è∏';
}

function togglePlay() {
  if (isMic) { stopAll(); showUI(); return; }

  if (isMediaEl) {
    if (!mediaEl) return;
    ensureCtx();
    if (isPlaying) {
      mediaEl.pause();
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '‚ñ∂';
    } else {
      mediaEl.play();
      isPlaying = true;
      document.getElementById('playPauseBtn').textContent = '‚è∏';
    }
    return;
  }

  if (!audioBuffer) return;
  ensureCtx();
  if (isPlaying) {
    pausedAt = actx.currentTime - startedAt;
    try { bufSrc.stop(); } catch(e){}
    isPlaying = false;
    document.getElementById('playPauseBtn').textContent = '‚ñ∂';
  } else { doPlay(pausedAt); }
}

async function startMic() {
  stopAll(); ensureCtx(); isMic = true;
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    const src = actx.createMediaStreamSource(micStream);
    src.connect(analyser);
    isPlaying = true;
    setTrackName('LIVE MIC'); hideUI(); showControls();
    document.getElementById('playPauseBtn').textContent = '‚èπ';
  } catch(err) { alert('Micro indisponible : ' + err.message); }
}

function stopAll() {
  if (bufSrc)  { try { bufSrc.stop(); bufSrc.disconnect(); } catch(e){} bufSrc = null; }
  if (mediaEl) {
    try { mediaEl.pause(); URL.revokeObjectURL(mediaEl.src); mediaEl.remove(); } catch(e){}
    mediaEl = null;
  }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  if (analyser)  { try { analyser.disconnect(); } catch(e){} }
  isPlaying = false; isMic = false; isMediaEl = false; audioBuffer = null;
}

/* =====================================================
   CANVAS / RENDER
===================================================== */
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
let W, H, cx, cy, tick = 0;
let gradCanvas = null;

/*
  30fps cap on mobile.
  On iPhone, 60fps for canvas-heavy work often triggers thermal throttling
  and drops to erratic framerates. A steady 30fps feels smoother in practice.
*/
const TARGET_MS = 1000 / 60;
let lastFrameTs = 0;

function resize() {
  W = canvas.width  = window.innerWidth;
  H = canvas.height = window.innerHeight;
  cx = W/2; cy = H/2;
  gradCanvas = null;
}
window.addEventListener('resize', resize);
resize();

let mode    = 'radial';
let palette = 'neon';
const PALETTES = {
  neon:    ['#ff006e','#8338ec','#3a86ff','#06d6a0'],
  fire:    ['#ff4d00','#ff8c00','#ffbe0b','#fffb69'],
  ocean:   ['#00b4d8','#06d6a0','#0077b6','#90e0ef'],
  mono:    ['#ffffff','#cccccc','#888888','#333333'],
  love:    ['#ff1a75','#ff6eb4','#ff0044','#ffb3d1'],
  drive:   ['#1a0533','#6600ff','#cc00ff','#ffffff'],
  liminal: ['#d4f0a0','#fffde0','#b8e0d2','#f7c59f'],
};
const cols = () => PALETTES[palette];

function colAt(t) {
  const c = cols();
  const scaled = Math.min(t, 0.9999) * (c.length - 1);
  const lo = scaled | 0;
  return lerpHex(c[lo], c[Math.min(lo + 1, c.length - 1)], scaled - lo);
}
const _hexCache = {};
function parseHex(h) {
  if (_hexCache[h]) return _hexCache[h];
  const r = parseInt(h.slice(1,3),16), g = parseInt(h.slice(3,5),16), b = parseInt(h.slice(5,7),16);
  return (_hexCache[h] = [r,g,b]);
}
function lerpHex(a, b, t) {
  const [ar,ag,ab_] = parseHex(a), [br,bg,bb] = parseHex(b);
  const r = (ar + (br-ar)*t)|0, g = (ag + (bg-ag)*t)|0, bv = (ab_ + (bb-ab_)*t)|0;
  return '#' + ((1<<24)|(r<<16)|(g<<8)|bv).toString(16).slice(1);
}

let particles    = [];
let orbFireBalls = [];
let orbCooldown  = 0;
let orbSubHist   = null;
let orbSubPrev   = 0;

function bandAvg(lo, hi) {
  if (!freqData) return 0;
  let s = 0;
  const end = Math.min(hi, freqData.length);
  for (let i = lo; i < end; i++) s += freqData[i];
  return s / ((end - lo) * 255);
}

/*
  Two-pass glow strategy ‚Äî the main iOS optimisation.

  Safari/iOS flushes the GPU pipeline on every ctx.shadowBlur state change.
  The original code toggled it per element (~160 changes/frame in Radial mode).

  Fix: draw all elements once without glow (pass 1), then re-draw only the
  "bright" subset with a single glow state set before the loop (pass 2).
  Result: 2 state changes per frame instead of ~160. Visual quality: identical.
*/
function glow(col, sz) { ctx.shadowBlur = sz; ctx.shadowColor = col; }
function noGlow()      { ctx.shadowBlur = 0; }

/* ---- MAIN LOOP ---- */
function loop(ts) {
  requestAnimationFrame(loop);
  if (ts - lastFrameTs < TARGET_MS) return;
  lastFrameTs = ts;

  tick++;
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(0, 0, W, H);

  if (!analyser || !isPlaying) { drawIdle(); return; }
  analyser.getByteFrequencyData(freqData);
  analyser.getByteTimeDomainData(waveData);

  switch (mode) {
    case 'radial': drawRadial(); break;
    case 'bars':   drawBars();   break;
    case 'wave':   drawWave();   break;
    case 'galaxy': drawGalaxy(); break;
    case 'bubble': drawOrb();    break;
  }
}
requestAnimationFrame(loop);

/* ---- IDLE ---- */
function drawIdle() {
  const c = cols(), t = tick / 60;
  for (let i = 0; i < 3; i++) {
    const r = 60 + i*55 + Math.sin(t*1.2 + i*1.3)*18;
    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.strokeStyle = c[i % c.length]; ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.18 + Math.sin(t*2 + i)*0.06;
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

/* ---- RADIAL ---- */
function drawRadial() {
  const half = Math.min(Math.floor(freqData.length / 2), 128);
  const base = Math.min(W,H)*0.20, max = Math.min(W,H)*0.44;
  const bass = bandAvg(0,4);

  const g = ctx.createRadialGradient(cx,cy,0,cx,cy,base*(1+bass*0.9));
  g.addColorStop(0, cols()[0]+'44'); g.addColorStop(1,'transparent');
  ctx.beginPath(); ctx.arc(cx,cy,base*(1+bass*0.8),0,Math.PI*2);
  ctx.fillStyle=g; ctx.globalAlpha=1; noGlow(); ctx.fill();

  /* Pass 1 ‚Äî all bars, no glow */
  noGlow();
  for (let i = 0; i < half; i++) {
    const v      = freqData[i] / 255;
    const t      = i / half;
    const col    = colAt(t);
    const angleR = (t - 0.5) * Math.PI;
    const angleL = Math.PI - angleR;
    const r2     = base + v*(max-base);
    const r3     = base - v*base*0.5;

    ctx.strokeStyle = col; ctx.lineWidth = 2;
    ctx.globalAlpha = 0.7 + v*0.3;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleR)*base, cy + Math.sin(angleR)*base);
    ctx.lineTo(cx + Math.cos(angleR)*r2,   cy + Math.sin(angleR)*r2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleL)*base, cy + Math.sin(angleL)*base);
    ctx.lineTo(cx + Math.cos(angleL)*r2,   cy + Math.sin(angleL)*r2);
    ctx.stroke();

    ctx.lineWidth = 1.2; ctx.globalAlpha = 0.3 + v*0.2;
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleR)*base, cy + Math.sin(angleR)*base);
    ctx.lineTo(cx + Math.cos(angleR)*r3,   cy + Math.sin(angleR)*r3);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleL)*base, cy + Math.sin(angleL)*base);
    ctx.lineTo(cx + Math.cos(angleL)*r3,   cy + Math.sin(angleL)*r3);
    ctx.stroke();
  }

  /* Pass 2 ‚Äî bright bars only, single glow state */
  glow(cols()[0], 14);
  for (let i = 0; i < half; i++) {
    const v = freqData[i] / 255;
    if (v <= 0.5) continue;
    const t      = i / half;
    const col    = colAt(t);
    const angleR = (t - 0.5) * Math.PI;
    const angleL = Math.PI - angleR;
    const r2     = base + v*(max-base);

    ctx.strokeStyle = col; ctx.shadowColor = col;
    ctx.lineWidth = 2; ctx.globalAlpha = (v - 0.5) * 0.9;

    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleR)*base, cy + Math.sin(angleR)*base);
    ctx.lineTo(cx + Math.cos(angleR)*r2,   cy + Math.sin(angleR)*r2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cx + Math.cos(angleL)*base, cy + Math.sin(angleL)*base);
    ctx.lineTo(cx + Math.cos(angleL)*r2,   cy + Math.sin(angleL)*r2);
    ctx.stroke();
  }

  ctx.globalAlpha = 1; noGlow();
}

/* ---- BARS ---- */
function drawBars() {
  const len  = Math.min(freqData.length, 80);
  const barW = W / len;

  /* Pass 1 ‚Äî all bars, no glow */
  noGlow();
  for (let i = 0; i < len; i++) {
    const v   = freqData[i] / 255;
    const bH  = v * H * 0.9;
    const x   = i * barW;
    const col = colAt(i / len);

    const grad = ctx.createLinearGradient(0, H-bH, 0, H);
    grad.addColorStop(0, col); grad.addColorStop(1, col + '18');
    ctx.fillStyle = grad; ctx.globalAlpha = 0.92;
    ctx.fillRect(x+1, H-bH, barW-2, bH);

    ctx.globalAlpha = 0.18; ctx.fillStyle = col;
    ctx.fillRect(x+1, 0, barW-2, v*H*0.3);
  }

  /* Pass 2 ‚Äî bright bars only, single glow state */
  glow(cols()[0], 18);
  for (let i = 0; i < len; i++) {
    const v = freqData[i] / 255;
    if (v <= 0.6) continue;
    const bH  = v * H * 0.9;
    const x   = i * barW;
    const col = colAt(i / len);

    ctx.shadowColor = col; ctx.fillStyle = col;
    ctx.globalAlpha = (v - 0.6) * 0.55;
    ctx.fillRect(x+1, H-bH, barW-2, bH);
  }

  ctx.globalAlpha = 1; noGlow();
}

/* ---- WAVE ‚Äî glow set once per layer (3 state changes total) ---- */
function drawWave() {
  const len = waveData.length, c = cols();
  for (let layer = 0; layer < 3; layer++) {
    ctx.beginPath();
    for (let i = 0; i <= len; i += 2) {
      const x   = (i / len) * W;
      const raw = ((waveData[i % len] / 128) - 1);
      const y   = cy + raw*(120+layer*50) + Math.sin(tick*0.025+layer*1.2+i*0.015)*(15+layer*8);
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    const col = c[layer % c.length];
    ctx.strokeStyle = col; ctx.lineWidth = 2.5 - layer*0.3;
    ctx.globalAlpha = 0.9 - layer*0.2;
    glow(col, 12 + layer*5);
    ctx.stroke();
  }
  ctx.globalAlpha = 1; noGlow();
}

/* ---- GALAXY ---- */
function drawGalaxy() {
  const c = cols(), bass = bandAvg(0,4);
  const spawnN = Math.floor(1 + bass*8);
  for (let s = 0; s < spawnN; s++) {
    if (particles.length >= 250) break;
    const a = Math.random() * Math.PI * 2;
    const spd = 0.8 + bass*5 + Math.random()*2;
    particles.push({
      x:cx, y:cy, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd,
      life:1, decay:0.01 + Math.random()*0.015,
      col:c[Math.floor(Math.random()*c.length)],
      size:1.5 + Math.random()*3 + bass*3
    });
  }
  noGlow();
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vx *= 1.015; p.vy *= 1.015; p.life -= p.decay;
    if (p.life <= 0 || p.x < -100 || p.x > W+100 || p.y < -100 || p.y > H+100) {
      particles.splice(i,1); continue;
    }
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size*p.life, 0, Math.PI*2);
    ctx.fillStyle = p.col; ctx.globalAlpha = p.life*0.85; ctx.fill();
  }
  ctx.beginPath(); ctx.arc(cx, cy, 35+bass*90, 0, Math.PI*2);
  ctx.strokeStyle = c[0]; ctx.lineWidth = 2+bass*5;
  ctx.globalAlpha = 0.55+bass*0.45;
  glow(c[0], 20+bass*35); ctx.stroke();
  ctx.globalAlpha = 1; noGlow();
}

/* ---- ORB ---- */
function drawOrb() {
  const bass = bandAvg(0, 6);
  const high = bandAvg(60, 256);
  const c    = cols();
  const R    = Math.min(W, H) * (0.20 + bass*0.08);

  noGlow();
  for (let layer = 2; layer >= 1; layer--) {
    const coronaR = R * (1.4 + layer*0.4 + bass*0.4);
    const gr = ctx.createRadialGradient(cx, cy, R*0.8, cx, cy, coronaR);
    gr.addColorStop(0, c[0] + Math.round((0.18+bass*0.12)*255).toString(16).padStart(2,'0'));
    gr.addColorStop(1, c[2] + '00');
    ctx.beginPath(); ctx.arc(cx, cy, coronaR, 0, Math.PI*2);
    ctx.fillStyle = gr; ctx.globalAlpha = 0.6 / layer; ctx.fill();
  }

  const gBody = ctx.createRadialGradient(cx, cy, 0, cx, cy, R);
  gBody.addColorStop(0,   c[0]+'ff');
  gBody.addColorStop(0.5, c[1]+'cc');
  gBody.addColorStop(1,   '#000000cc');
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.fillStyle = gBody; ctx.globalAlpha = 0.92;
  glow(c[0], 40 + bass*60); ctx.fill();

  noGlow();
  const hx = cx - R*0.30, hy = cy - R*0.32;
  const gSpec = ctx.createRadialGradient(hx, hy, 0, hx, hy, R*0.45);
  gSpec.addColorStop(0, '#ffffff' + Math.round((0.7+high*0.3)*255).toString(16).padStart(2,'0'));
  gSpec.addColorStop(1, '#ffffff00');
  ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2);
  ctx.fillStyle = gSpec; ctx.globalAlpha = 1; ctx.fill();

  const subBass = bandAvg(0, 5);
  if (!orbSubHist) orbSubHist = new Float32Array(40).fill(subBass);
  orbSubHist.copyWithin(1, 0); orbSubHist[0] = subBass;

  let subMin = orbSubHist[0], subMax = orbSubHist[0];
  for (let i = 1; i < orbSubHist.length; i++) {
    if (orbSubHist[i] < subMin) subMin = orbSubHist[i];
    if (orbSubHist[i] > subMax) subMax = orbSubHist[i];
  }
  const subRange = subMax - subMin;
  const subNorm  = subRange > 0.01 ? (subBass - subMin) / subRange : 0;
  const subRise  = subNorm - orbSubPrev;
  orbSubPrev = subNorm;

  orbCooldown = Math.max(0, orbCooldown - 1);
  if (subRise > 0.25 && subNorm > 0.5 && orbCooldown === 0) {
    orbCooldown = 10;
    const intensity = subNorm * subRise * 4;
    const absScale  = Math.min(subBass * 4, 1);
    const count     = Math.floor(3 + intensity*6);
    for (let k = 0; k < Math.min(count, 8); k++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + intensity*5 + Math.random()*2;
      const size  = (4 + intensity*10 + Math.random()*5) * (0.3 + absScale*0.7);
      orbFireBalls.push({
        x: cx + Math.cos(angle)*(R*0.95),
        y: cy + Math.sin(angle)*(R*0.95),
        vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
        life:1, decay:0.018+Math.random()*0.018,
        size, col1:c[0], col2:c[1%c.length]
      });
    }
  }

  /* Pass 1 ‚Äî outer flames, no glow */
  noGlow();
  for (let i = orbFireBalls.length-1; i >= 0; i--) {
    const fb = orbFireBalls[i];
    fb.x += fb.vx; fb.y += fb.vy;
    fb.vx *= 0.97; fb.vy *= 0.97;
    fb.life -= fb.decay;
    if (fb.life <= 0) { orbFireBalls.splice(i,1); continue; }
    const r = fb.size * fb.life;
    ctx.beginPath(); ctx.arc(fb.x, fb.y, r*1.8, 0, Math.PI*2);
    ctx.fillStyle = fb.col2; ctx.globalAlpha = fb.life * 0.5; ctx.fill();
  }

  /* Pass 2 ‚Äî hot white cores, single glow state */
  glow(c[0], 16);
  for (let i = 0; i < orbFireBalls.length; i++) {
    const fb = orbFireBalls[i];
    const r  = fb.size * fb.life;
    ctx.beginPath(); ctx.arc(fb.x, fb.y, r*0.6, 0, Math.PI*2);
    ctx.fillStyle = '#ffffff'; ctx.globalAlpha = fb.life * 0.9;
    ctx.shadowColor = fb.col1; ctx.fill();
  }

  if (orbFireBalls.length > 40) orbFireBalls.splice(0, orbFireBalls.length - 40);
  ctx.globalAlpha = 1; noGlow();
}

/* =====================================================
   UI
===================================================== */
function setMode(btn) {
  mode = btn.dataset.mode;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  particles = []; orbFireBalls = [];
  orbSubHist = null; orbSubPrev = 0; orbCooldown = 0;
}
function setPalette(p, el) {
  palette = p;
  document.querySelectorAll('.pal').forEach(e => e.classList.remove('active'));
  el.classList.add('active');
  Object.keys(_hexCache).forEach(k => delete _hexCache[k]);
}
function hideUI()      { document.getElementById('ui').classList.add('hidden'); }
function showUI()      { document.getElementById('ui').classList.remove('hidden'); }
function showControls(){ document.getElementById('controls').classList.add('visible'); }
function setTrackName(n) {
  const el = document.getElementById('trackName');
  el.textContent = n; el.classList.add('visible');
}

let allHidden = false;
function toggleAllUI() {
  allHidden = !allHidden;
  const controls  = document.getElementById('controls');
  const trackName = document.getElementById('trackName');
  controls.style.opacity       = allHidden ? '0' : '';
  controls.style.pointerEvents = allHidden ? 'none' : '';
  trackName.style.opacity      = allHidden ? '0' : '';
}

canvas.addEventListener('click', e => {
  if (e.target !== canvas) return;
  if (isPlaying) toggleAllUI();
});
</script>
</body>
</html>
