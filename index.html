<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<title>Audio Visualizer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Mono:wght@400;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --c1: #ff006e;
    --c2: #8338ec;
    --c3: #3a86ff;
    --c4: #ffbe0b;
    --bg: #000000;
  }

  body {
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100dvh;
    overflow: hidden;
    font-family: 'Space Mono', monospace;
    color: #fff;
  }

  #canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  .ui {
    position: fixed;
    z-index: 10;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
    transition: opacity 0.6s ease;
  }

  .ui.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .title {
    font-family: 'Bebas Neue', sans-serif;
    font-size: clamp(2.5rem, 10vw, 4rem);
    letter-spacing: 0.15em;
    background: linear-gradient(135deg, var(--c1), var(--c2), var(--c3));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-align: center;
    filter: drop-shadow(0 0 20px var(--c1));
    animation: pulse-title 3s ease-in-out infinite;
  }

  @keyframes pulse-title {
    0%, 100% { filter: drop-shadow(0 0 20px var(--c1)); }
    50% { filter: drop-shadow(0 0 40px var(--c2)); }
  }

  .btn-group {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .btn {
    padding: 14px 28px;
    border: 2px solid transparent;
    border-radius: 4px;
    background: transparent;
    color: #fff;
    font-family: 'Space Mono', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--c1), var(--c2));
    opacity: 0.15;
    transition: opacity 0.3s;
  }

  .btn:hover::before { opacity: 0.35; }

  .btn-primary {
    border-color: var(--c1);
    box-shadow: 0 0 20px rgba(255,0,110,0.4), inset 0 0 20px rgba(255,0,110,0.1);
  }

  .btn-secondary {
    border-color: var(--c2);
    box-shadow: 0 0 20px rgba(131,56,236,0.4), inset 0 0 20px rgba(131,56,236,0.1);
  }

  .btn-accent {
    border-color: var(--c3);
    box-shadow: 0 0 20px rgba(58,134,255,0.4);
  }

  #fileInput { display: none; }

  .hint {
    font-size: 0.65rem;
    color: rgba(255,255,255,0.4);
    letter-spacing: 0.05em;
    text-align: center;
    max-width: 280px;
    line-height: 1.6;
  }

  /* Playing controls */
  .controls {
    position: fixed;
    bottom: 40px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    display: flex;
    gap: 16px;
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .controls.visible { opacity: 1; }

  .ctrl-btn {
    width: 56px; height: 56px;
    border-radius: 50%;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(0,0,0,0.5);
    backdrop-filter: blur(10px);
    color: #fff;
    font-size: 1.1rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
  }

  .ctrl-btn:hover {
    border-color: var(--c1);
    box-shadow: 0 0 20px rgba(255,0,110,0.5);
  }

  /* Palette selector */
  .palette-row {
    display: flex;
    gap: 10px;
    align-items: center;
  }

  .pal {
    width: 28px; height: 28px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: transform 0.2s, border-color 0.2s;
  }

  .pal:hover, .pal.active {
    transform: scale(1.2);
    border-color: #fff;
  }

  .pal-neon { background: linear-gradient(135deg, #ff006e, #8338ec); }
  .pal-fire { background: linear-gradient(135deg, #ff4d00, #ffbe0b); }
  .pal-ocean { background: linear-gradient(135deg, #00b4d8, #06d6a0); }
  .pal-mono { background: linear-gradient(135deg, #ffffff, #555); }

  /* Mode selector */
  .mode-row {
    display: flex;
    gap: 8px;
  }

  .mode-btn {
    padding: 6px 14px;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 20px;
    background: transparent;
    color: rgba(255,255,255,0.5);
    font-family: 'Space Mono', monospace;
    font-size: 0.6rem;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 0.05em;
  }

  .mode-btn.active {
    border-color: var(--c1);
    color: #fff;
    background: rgba(255,0,110,0.15);
  }

  .track-name {
    position: fixed;
    top: 30px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    font-family: 'Bebas Neue', sans-serif;
    font-size: 1.2rem;
    letter-spacing: 0.2em;
    color: rgba(255,255,255,0.7);
    opacity: 0;
    transition: opacity 0.5s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80vw;
    text-align: center;
  }

  .track-name.visible { opacity: 1; }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div class="ui" id="ui">
  <div class="title">VISUALIZER</div>

  <div class="mode-row">
    <button class="mode-btn active" onclick="setMode('radial')">RADIAL</button>
    <button class="mode-btn" onclick="setMode('bars')">BARS</button>
    <button class="mode-btn" onclick="setMode('wave')">WAVE</button>
    <button class="mode-btn" onclick="setMode('galaxy')">GALAXY</button>
  </div>

  <div class="btn-group">
    <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">
      ‚¨Ü Importer un son
    </button>
    <button class="btn btn-secondary" onclick="startMic()">
      üé§ Micro live
    </button>
  </div>

  <div class="palette-row">
    <div class="pal pal-neon active" onclick="setPalette('neon',this)" title="Neon"></div>
    <div class="pal pal-fire" onclick="setPalette('fire',this)" title="Fire"></div>
    <div class="pal pal-ocean" onclick="setPalette('ocean',this)" title="Ocean"></div>
    <div class="pal pal-mono" onclick="setPalette('mono',this)" title="Mono"></div>
  </div>

  <div class="hint">Importe un fichier audio ou utilise ton micro.<br>Enregistre ton √©cran et poste sur TikTok üéµ</div>
</div>

<div class="track-name" id="trackName"></div>

<div class="controls" id="controls">
  <button class="ctrl-btn" id="playPauseBtn" onclick="togglePlay()">‚è∏</button>
  <button class="ctrl-btn" onclick="showUI()">‚ú¶</button>
</div>

<input type="file" id="fileInput" accept="audio/*" onchange="loadFile(event)">

<script>
// ---- State ----
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let audioCtx, analyser, source, audioBuffer, gainNode;
let animFrame;
let isPlaying = false;
let startedAt = 0, pausedAt = 0;
let mode = 'radial';
let palette = 'neon';
let isMic = false;

const palettes = {
  neon:  ['#ff006e','#8338ec','#3a86ff','#06d6a0'],
  fire:  ['#ff4d00','#ff8c00','#ffbe0b','#fff275'],
  ocean: ['#00b4d8','#06d6a0','#0077b6','#90e0ef'],
  mono:  ['#ffffff','#cccccc','#888888','#444444'],
};

function getColors() { return palettes[palette]; }

// ---- Resize ----
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ---- Audio setup ----
function initAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 2048;
    gainNode = audioCtx.createGain();
    analyser.connect(gainNode);
    gainNode.connect(audioCtx.destination);
  }
}

// ---- File load ----
function loadFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  isMic = false;
  initAudioCtx();
  const reader = new FileReader();
  reader.onload = async (ev) => {
    if (source) { try { source.stop(); } catch(e){} source.disconnect(); }
    audioBuffer = await audioCtx.decodeAudioData(ev.target.result);
    pausedAt = 0;
    startPlayback();
    const name = file.name.replace(/\.[^.]+$/, '').toUpperCase();
    document.getElementById('trackName').textContent = name;
    document.getElementById('trackName').classList.add('visible');
    hideUI();
  };
  reader.readAsArrayBuffer(file);
}

function startPlayback(offset = 0) {
  if (source) { try { source.stop(); } catch(e){} source.disconnect(); }
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(analyser);
  source.start(0, offset);
  startedAt = audioCtx.currentTime - offset;
  isPlaying = true;
  document.getElementById('playPauseBtn').textContent = '‚è∏';
  document.getElementById('controls').classList.add('visible');
  if (!animFrame) draw();
}

function togglePlay() {
  if (!audioBuffer) return;
  if (isPlaying) {
    pausedAt = audioCtx.currentTime - startedAt;
    source.stop();
    isPlaying = false;
    document.getElementById('playPauseBtn').textContent = '‚ñ∂';
  } else {
    startPlayback(pausedAt);
  }
}

// ---- Mic ----
async function startMic() {
  isMic = true;
  initAudioCtx();
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    if (source) { try { source.stop(); } catch(e){} source.disconnect(); }
    source = audioCtx.createMediaStreamSource(stream);
    source.connect(analyser);
    gainNode.gain.value = 0; // no feedback
    isPlaying = true;
    document.getElementById('controls').classList.add('visible');
    document.getElementById('trackName').textContent = 'LIVE MIC';
    document.getElementById('trackName').classList.add('visible');
    hideUI();
    if (!animFrame) draw();
  } catch(e) {
    alert("Micro non disponible : " + e.message);
  }
}

// ---- UI toggle ----
let uiHidden = false;
function hideUI() {
  document.getElementById('ui').classList.add('hidden');
  uiHidden = true;
}
function showUI() {
  document.getElementById('ui').classList.remove('hidden');
  uiHidden = false;
}

function setMode(m) {
  mode = m;
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
}

function setPalette(p, el) {
  palette = p;
  document.querySelectorAll('.pal').forEach(e => e.classList.remove('active'));
  el.classList.add('active');
}

// ---- Drawing ----
const dataArray = () => {
  if (!analyser) return new Uint8Array(0);
  const arr = new Uint8Array(analyser.frequencyBinCount);
  analyser.getByteFrequencyData(arr);
  return arr;
};

const waveArray = () => {
  if (!analyser) return new Uint8Array(0);
  const arr = new Uint8Array(analyser.fftSize);
  analyser.getByteTimeDomainData(arr);
  return arr;
};

let particles = [];
let time = 0;

function draw() {
  animFrame = requestAnimationFrame(draw);
  const W = canvas.width, H = canvas.height;
  time++;

  // Background fade
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(0, 0, W, H);

  if (!analyser) return;

  const data = dataArray();
  const cols = getColors();
  const cx = W / 2, cy = H / 2;

  if (mode === 'radial') drawRadial(data, cols, W, H, cx, cy);
  else if (mode === 'bars') drawBars(data, cols, W, H);
  else if (mode === 'wave') drawWave(cols, W, H, cx, cy);
  else if (mode === 'galaxy') drawGalaxy(data, cols, W, H, cx, cy);
}

function avg(data, start, end) {
  let s = 0;
  for (let i = start; i < end; i++) s += data[i];
  return s / (end - start);
}

function drawRadial(data, cols, W, H, cx, cy) {
  const len = data.length;
  const baseR = Math.min(W, H) * 0.22;
  const maxR = Math.min(W, H) * 0.42;
  const bass = avg(data, 0, 8) / 255;

  // Glow core
  const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, baseR * (1 + bass));
  grd.addColorStop(0, cols[0] + '55');
  grd.addColorStop(1, 'transparent');
  ctx.beginPath();
  ctx.arc(cx, cy, baseR * (1 + bass * 0.8), 0, Math.PI * 2);
  ctx.fillStyle = grd;
  ctx.fill();

  // Bars around circle
  for (let i = 0; i < len; i++) {
    const angle = (i / len) * Math.PI * 2 - Math.PI / 2;
    const v = data[i] / 255;
    const r1 = baseR;
    const r2 = baseR + v * (maxR - baseR);
    const x1 = cx + Math.cos(angle) * r1;
    const y1 = cy + Math.sin(angle) * r1;
    const x2 = cx + Math.cos(angle) * r2;
    const y2 = cy + Math.sin(angle) * r2;

    const ci = Math.floor((i / len) * cols.length);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = cols[ci % cols.length];
    ctx.lineWidth = 2.5;
    ctx.globalAlpha = 0.8 + v * 0.2;
    ctx.shadowBlur = 12 + v * 20;
    ctx.shadowColor = cols[ci % cols.length];
    ctx.stroke();
  }

  // Mirror
  for (let i = 0; i < len; i++) {
    const angle = (i / len) * Math.PI * 2 - Math.PI / 2;
    const v = data[i] / 255;
    const r1 = baseR;
    const r2 = baseR - v * (baseR * 0.6);
    const x1 = cx + Math.cos(angle) * r1;
    const y1 = cy + Math.sin(angle) * r1;
    const x2 = cx + Math.cos(angle) * r2;
    const y2 = cy + Math.sin(angle) * r2;

    const ci = Math.floor((i / len) * cols.length);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = cols[(ci + 1) % cols.length];
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.4 + v * 0.3;
    ctx.stroke();
  }

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawBars(data, cols, W, H) {
  const len = Math.min(data.length, 128);
  const barW = W / len;
  const bass = avg(data, 0, 8) / 255;

  for (let i = 0; i < len; i++) {
    const v = data[i] / 255;
    const bH = v * H * 0.85;
    const x = i * barW;
    const ci = Math.floor((i / len) * cols.length);
    const col = cols[ci % cols.length];

    // Bottom bar
    const g = ctx.createLinearGradient(0, H, 0, H - bH);
    g.addColorStop(0, col + 'ff');
    g.addColorStop(1, col + '44');
    ctx.fillStyle = g;
    ctx.shadowBlur = 15 + v * 25;
    ctx.shadowColor = col;
    ctx.fillRect(x + 1, H - bH, barW - 2, bH);

    // Mirror top
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = col;
    ctx.fillRect(x + 1, 0, barW - 2, v * H * 0.4);
    ctx.globalAlpha = 1;
  }

  ctx.shadowBlur = 0;
}

function drawWave(cols, W, H, cx, cy) {
  const wave = waveArray();
  const len = wave.length;

  for (let layer = 0; layer < 3; layer++) {
    ctx.beginPath();
    for (let i = 0; i < len; i++) {
      const x = (i / len) * W;
      const offset = ((wave[i] / 128) - 1) * (80 + layer * 40);
      const y = cy + offset + Math.sin(time * 0.02 + layer + i * 0.02) * 20;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.strokeStyle = cols[layer % cols.length];
    ctx.lineWidth = 3 - layer * 0.5;
    ctx.globalAlpha = 1 - layer * 0.2;
    ctx.shadowBlur = 20;
    ctx.shadowColor = cols[layer % cols.length];
    ctx.stroke();
  }

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawGalaxy(data, cols, W, H, cx, cy) {
  const len = data.length;
  const bass = avg(data, 0, 8) / 255;
  const mid  = avg(data, 8, 64) / 255;
  const high = avg(data, 64, 256) / 255;

  // Spawn particles
  if (particles.length < 300 && Math.random() < 0.4 + bass * 0.6) {
    const angle = Math.random() * Math.PI * 2;
    const speed = (1 + bass * 4) * (Math.random() + 0.5);
    const ci = Math.floor(Math.random() * cols.length);
    particles.push({
      x: cx, y: cy,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      decay: 0.006 + Math.random() * 0.012,
      col: cols[ci],
      size: 2 + Math.random() * 4 * bass,
    });
  }

  // Draw & update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 1.01;
    p.vy *= 1.01;
    p.life -= p.decay;

    if (p.life <= 0 || p.x < -50 || p.x > W + 50 || p.y < -50 || p.y > H + 50) {
      particles.splice(i, 1); continue;
    }

    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fillStyle = p.col;
    ctx.globalAlpha = p.life;
    ctx.shadowBlur = 15;
    ctx.shadowColor = p.col;
    ctx.fill();
  }

  // Central ring
  ctx.beginPath();
  ctx.arc(cx, cy, 40 + bass * 80, 0, Math.PI * 2);
  ctx.strokeStyle = cols[0];
  ctx.lineWidth = 3 + bass * 5;
  ctx.globalAlpha = 0.6 + bass * 0.4;
  ctx.shadowBlur = 30 + bass * 40;
  ctx.shadowColor = cols[0];
  ctx.stroke();

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

// Idle animation
function idleLoop() {
  if (analyser && isPlaying) return;
  animFrame = requestAnimationFrame(idleLoop);
  const W = canvas.width, H = canvas.height;
  ctx.fillStyle = 'rgba(0,0,0,0.05)';
  ctx.fillRect(0, 0, W, H);

  const cx = W/2, cy = H/2;
  const cols = getColors();
  const t = Date.now() / 1000;

  for (let i = 0; i < 3; i++) {
    const r = 80 + i * 50 + Math.sin(t + i) * 20;
    const alpha = 0.15 + i * 0.05;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.strokeStyle = cols[i % cols.length];
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = alpha + Math.sin(t * 2 + i) * 0.05;
    ctx.shadowBlur = 20;
    ctx.shadowColor = cols[i % cols.length];
    ctx.stroke();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

idleLoop();
</script>
</body>
</html>
